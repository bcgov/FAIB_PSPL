---
title: "Raster Point Intersect"
author: "D. Waddell"
date: "`r Sys.Date()`"
output: md_document
---

## VRI raster intersect with PSPL points 

Assumes that PSPL GDBs are already copied and unzipped


Start: `r Sys.time()`

```{r read_data}

library(sf)
library(terra)
library(RPostgreSQL)

# set up for load to PostgreSQL
schema <- 'msyt_2022'
opt <- paste0("-c search_path=",schema)
user_name <- 'postgres'
database <- 'msyt'
con <- dbConnect('PostgreSQL',dbname=database,user=user_name,options=opt)


# read Provincial fid tif
fn1 <- paste0(substr(getwd(),1,1),':/data/data_projects/AR2022/PSPL/vri_raster.tif')
raster_fid <- rast(fn1)


# this is where the unzipped files are placed locally
local_pspl_folder <- paste0(substr(getwd(),1,1),':/data/data_projects/AR2022/PSPL/gdb_data')

# build list of the PSPL gdbs
# list of gdb files to process
f_list <- list.files(local_pspl_folder,full.names = TRUE)
num_gdb = length(f_list)  #number of files to process

```

## process each gdb 

- Read each GDB
- extract feature id from the raster using extract
- join to the point attribute data
- crop the PROV raster at the extent of each GDB + 51m
- export to PostgreSQL table: pspl_raw

```{r fun}

rast_intersect <- function(r,pf,n){
  
  # r = PROV raster of fid
  # pf = PSPL point set
  # n = counter
  
  # read the point file
  point_set <- vect(pf)
  
  
  # lower case the names
  names(point_set) <- c("id_tag","at_si","ba_si","bg_si","bl_si","cw_si","dr_si","ep_si","fd_si","hm_si","hw_si","lt_si","lw_si","pa_si","pl_si","pw_si","py_si","sb_si","se_si","ss_si","sw_si","sx_si","yc_si","bapid","pem_spp","bgc_label","tsa_number")
  
  # number points i pspl
  n_points <- nrow(point_set)


  # add id to point data
  point_set$pspl_id <- seq(1:nrow(point_set))


  #crop raster to point extent + 51

  # define extent from p add 1 m all around
  e <- ext(point_set)
  e[1] <- e[1] - 51
  e[2] <- e[2] + 51
  e[3] <- e[3] - 51
  e[4] <- e[4] + 51

  # crop the raster using the extent
  cropped_raster <- crop(r,e)
  
  
  
  # extract the raster data at the x,y of the points
  x <- extract(cropped_raster,point_set)

  # drop the geometry by changing to data frame
  point_set <- as.data.frame(point_set)


  # join raster data feature_id
  point_set$feature_id <- x[,"feature_id"]

  
  
  # set to 1 decimal place 
  # this matches the output from the Biophysical model
  
  # note that this works for CSV
  # export to PostgreSQL will keep as double
  # unless field.types are specified
  # but this has to be a named vector
  # handle the conversion in SQL
  
  point_set[, 2:23] <- round(point_set[, 2:23], digits = 1)

  
  # add a table number to allow tracking
  point_set$tab_no <- n
  
  # at this point can drop anything with a NULL feature_id
  # or can do this as first step in SQL
  

  # export to csv, append if exists
  #fn3 <- paste0(substr(getwd(),1,1),':/Data/data_projects/PSPL_2021/data/csv/csv',n,'.csv')
  #data.table::fwrite(p,fn3,sep=',',append=FALSE)
  
  # load to PostgreSQL
  if (n ==1) {
    dbWriteTable(con,'pspl_raw',point_set,row.names=FALSE,overwrite=TRUE)
  } else {
    dbWriteTable(con,'pspl_raw',point_set,row.names=FALSE,overwrite=FALSE,append = TRUE)
  }
  
  
  rows_out <- nrow(point_set)
  
  fo <- data.frame('num_points' = n_points,'rows_out' = rows_out, 'n' = n)
  
  return(fo)

}

```


```{r intersect_all_units}

# creates unit1 .. unitxx depending on the number of GDBs
  # unit1 does NOT refer to tsa 01
  # it is simply a reference number
if(length(f_list) ==0 ) { print("file list EMPTY")}

# initialize the counter
n <- 1

# create reporting data frame
report <- data.frame('num_points' = '','rows_out' = '', 'n' = '')





#process the file list
    for(fname in f_list){
      
      a <- rast_intersect(raster_fid,fname,n)
      
      report <- rbind(report,a)
      
      n <- n + 1
      
    }



```


```{r report}


library(kableExtra)

kable(report,format="markdown") %>%
kable_styling(bootstrap_options = c("striped"),full_width=F,font_size=13,position = 'left')

dbDisconnect(con)


```




Table 1.  PSPL Summary  

End: `r Sys.time()`


